from pycohconstraints.support import transpose, diagonallists
from pycohconstraints.support import make_vrep, make_hrep
from cdd import RepType, Polyhedron

def generate_asl_vrep(K, num_type='fraction'):
    """Generate the V-representation of avoiding sure loss

    See Equation (5) in my ISIPTA '13 paper “Characterizing coherence,
    correcting incoherence”.

    """
    deg_prevs = transpose(K)
    neg_dirs = diagonallists([-1] * len(K))
    return make_vrep(deg_prevs, neg_dirs, num_type)

def get_asl_hrep_via_vrep_raw(K, num_type='fraction'):
    """Compute an H-representation for avoiding sure loss

    We facet enumerate the V-representation generated by
    `generate_asl_vrep`. See Procedure A.1 in my ISIPTA '13 paper
    “Characterizing coherence, correcting incoherence”.

    """
    vrep = generate_asl_vrep(K, num_type)
    hrep = Polyhedron(vrep).get_inequalities()
    return hrep

def get_asl_hrep_via_vrep(K, num_type='fraction'):
    """Compute a minimal H-representation for avoiding sure loss

    We remove redundant constraints from the H-representation generated by `get_asl_hrep_via_vrep_raw`. (The fact that this representation can be
    redundant may be a cddlib bug; no response to a query concerning this
    issue has yet been receied from the cddlib author.)

    """
    hrep = get_asl_hrep_via_vrep_raw(K, num_type)
    hrep.canonicalize()
    return hrep

def get_asl_lhs_rhs_as_coeff_vrep(K, num_type='fraction'):
    """Compute a partial H-representation for positive avoiding sure loss

    See Procedure B.3 in my ISIPTA '13 paper “Characterizing coherence,
    correcting incoherence”; this function does not add positivity
    costraints or do redundancy removal.

    """
    k = len(K)
    coeff_lhs = transpose(K) + diagonallists([-1] * k)
    coeff_rhs = ([1] * (len(coeff_lhs) - k)) + ([0] * k)
    coeff_hrep = make_hrep(coeff_lhs, coeff_rhs, num_type)
    coeff_vrep = Polyhedron(coeff_hrep).get_generators()
    lhs = [list(t[1:]) for t in coeff_vrep[:]]
    rhs = [t[0] for t in coeff_vrep[:]]
    return lhs, rhs

def get_asl_hrep_as_coeff_vrep(K, num_type='fraction'):
    """Compute a minimal H-representation for positive avoiding sure loss

    See Procedure B.3 in my ISIPTA '13 paper “Characterizing coherence,
    correcting incoherence”; this function adds positivity costraints and
    does redundancy removal on the output of
    `get_asl_lhs_rhs_as_coeff_vrep`.

    """
    k = len(K)
    lhs, rhs = get_asl_lhs_rhs_as_coeff_vrep(K, num_type)
    pos_lhs = diagonallists([-1] * k)
    pos_rhs = ([0] * k)
    hrep = make_hrep(lhs + pos_lhs, rhs + pos_rhs, num_type)
    hrep.canonicalize()
    return hrep
