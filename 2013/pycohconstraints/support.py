from random import Random
from cdd import RepType, Matrix
from itertools import product

zeroslists = lambda listnum, listlen: [[0 for _ in xrange(listlen)]
                                       for _ in xrange(listnum)]

def indicatorslist(statenum):
    """Generate a list of all {0,1}-valued lists of length `statenum`"""
    indicatortuples = product({0, 1}, repeat=statenum)
    return [list(t) for t in indicatortuples]

def transpose(listoflists):
    """Transpose a list of lists, where each list is seen as a row"""
    listlen = len(listoflists[0])
    return [[l[k] for l in listoflists] for k in xrange(listlen)]

def diagonallists(diagonallist):
    """Create a list of lists with zeros expect on the diagonal

    Create a list of lists, where each list is the row of a diagonal matrix
    and the diagonal elements are taken from the input list `diagonallist`.

    """
    n = len(diagonallist)
    outputlist = zeroslists(n, n)
    for k in xrange(n):
        outputlist[k][k] = diagonallist[k]
    return outputlist

randint = lambda rngen, cutoff: rngen.randint(1, 9) * (rngen.random() > cutoff)

def randintlist(rngen, cutoff, listlen):
    """Returns a list of integers between 0 and 9, inclusive

    The list is randomly generated by the random generator `rngen`. The
    number of nonzero components is governed by `cutoff`. The list is NNZM:
    there is at least one zero and it is not identically zero.

    """
    listmax = 0
    while listmax == 0:
      random_list = [randint(rngen, cutoff) for _ in xrange(listlen)]
      listmin = min(random_list)
      NNZM_list = [val - listmin for val in random_list]
      listmax = max(NNZM_list)
    return NNZM_list

def randintlists(listnum, listlen):
    """Returns a list of list of integers between 0 and 9, inclusive

    The number of nonzero components of each list is randomly determined,
    but governed by a randomly generated parameter shared by all the lists.
    The nonzero values are uniformly random integers between 1 and 9,
    inclusive. The lists are NNZM: there is at least one zero and they are
    not identically zero.

    """
    rngen = Random()
    cutoff = rngen.random() * .15 + .85
    output = [randintlist(rngen, cutoff, listlen) for _ in xrange(listnum)]
    sparsity = float(sum(l.count(0) for l in output)) / (listnum * listlen)
    return output, sparsity

def make_vrep(points, rays, num_type='fraction'):
    """Create a V-representation cdd.Matrix

    The suggestively named input lists of lists should have element lists
    of equal length and integer values.

    """
    for pointlist in points:
      pointlist.insert(0, 1)
    for raylist in rays:
      raylist.insert(0, 0)
    mat = Matrix(points + rays, number_type=num_type)
    mat.rep_type = RepType.GENERATOR
    return mat

def lhs_rhs2constraints(lhs, rhs):
    """Transform constraints from double to single list representation

    The input `lhs` is a list of lists of numbers, each list representing
    the left-hand side coefficients of a linear constraint. The input `rhs`
    is a list of numbers representing the corresponding right-hand sides.
    The output is the list of lists [rhs, -lhs] (in block notation).

    """
    constraints = []
    for k in xrange(len(rhs)):
        constraints.append([rhs[k]] + [-coeff for coeff in lhs[k]])
    return constraints

def make_hrep(lhs, rhs, num_type='fraction'):
    """Create an H-representation cdd.Matrix

    The `lhs` input list of lists should have element lists of equal length
    and integer values; the `rhs` list should have length equal to `lhs`
    and integer values.

    """
    mat = Matrix(lhs_rhs2constraints(lhs, rhs), number_type=num_type)
    mat.rep_type = RepType.INEQUALITY
    return mat
